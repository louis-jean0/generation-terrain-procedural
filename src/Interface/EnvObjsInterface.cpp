#include "EnvObjsInterface.h"

#include "Interface/HierarchicalListWidget.h"
#include "Interface/InterfaceUtils.h"

EnvObjsInterface::EnvObjsInterface(QWidget *parent)
    : ActionInterface("envobjects", "Environmental Objects", "model", "Management of environmental objects generation", "envobjs_button.png", parent)
{

}

void EnvObjsInterface::affectTerrains(std::shared_ptr<Heightmap> heightmap, std::shared_ptr<VoxelGrid> voxelGrid, std::shared_ptr<LayerBasedGrid> layerGrid, std::shared_ptr<ImplicitNaryOperator> implicitPatch)
{
    ActionInterface::affectTerrains(heightmap, voxelGrid, layerGrid, implicitPatch);
}

void EnvObjsInterface::display(const Vector3 &camPos)
{
    if (!this->visible)
        return;
}

void EnvObjsInterface::replay(nlohmann::json action)
{

}

QLayout *EnvObjsInterface::createGUI()
{
    QLayout* layout = new QVBoxLayout;

    QCheckBox* displayCurrentsButton = new QCheckBox("Display currents");
    // TODO: Simulation type
    QCheckBox* displaySedimentsButton = new QCheckBox("Display sediments");
    QCheckBox* displayHighCurrentsButton = new QCheckBox("Display heigh currents");

    QPushButton* instantiateButton = new QPushButton("Instantiate");
    QPushButton* instantiatePassButton = new QPushButton("Passe");
    QPushButton* instantiateReefButton = new QPushButton("Reef");
    QPushButton* instantiateIslandButton = new QPushButton("Island");
    QPushButton* instantiateBoulderButton = new QPushButton("Boulder");
    QPushButton* instantiateDeltaButton = new QPushButton("Delta");

    HierarchicalListWidget* objectsListWidget = new HierarchicalListWidget;

    layout->addWidget(displayCurrentsButton);
    layout->addWidget(displaySedimentsButton);
    layout->addWidget(displayHighCurrentsButton);

    layout->addWidget(instantiateButton);
    layout->addWidget(createVerticalGroup({
                                              instantiatePassButton,
                                              instantiateReefButton,
                                              instantiateIslandButton,
                                              instantiateBoulderButton,
                                              instantiateDeltaButton
                                          }));
    layout->addWidget(objectsListWidget);

    return layout;
}

void EnvObjsInterface::show()
{
    ActionInterface::show();
}

void EnvObjsInterface::hide()
{
    ActionInterface::hide();
}

void EnvObjsInterface::afterTerrainUpdated()
{

}

void EnvObjsInterface::instantiateObject()
{
    /*voxelGrid->computeFlowfield(LBM, 1, implicitTerrain.get());
    GridF terrainSurface = voxelGrid->getVoxelValues().binarize();
    GridV3 waterFlow = voxelGrid->getFlowfield().resize(Vector3(10, 10, 10), RESIZE_MODE::MAX_VAL).resize(terrainSurface.getDimensions());
    GridV3 surfaceNormals = terrainSurface.toDistanceMap().gradient();
    for (size_t i = 0; i < surfaceNormals.size(); i++)
        surfaceNormals[i].normalize();

    terrainSurface = terrainSurface - terrainSurface.erode();
    std::vector<Vector3> availablePositions;
    availablePositions.reserve(terrainSurface.sizeX * terrainSurface.sizeY * 2);
    for (size_t i = 0; i < terrainSurface.size(); i++)
        if (terrainSurface[i]) availablePositions.push_back(terrainSurface.getCoordAsVector3(i));

    // Get 1000 random points
    std::shuffle(availablePositions.begin(), availablePositions.end(), random_gen::random_generator);
    availablePositions.resize(std::min(1000, int(availablePositions.size())));


    if (this->implicitTerrain->findAll(ImplicitPatch::ParametricTunnel).empty()) {
        this->autoGeneratePasse(terrainSurface, waterFlow, surfaceNormals, availablePositions);
    } else if (this->implicitTerrain->findAll(ImplicitPatch::ParametricTunnel).size() == 1) {
        this->autoGenerateDelta(terrainSurface, waterFlow, surfaceNormals, availablePositions);
    } else {
        this->autoGenerateMotu(terrainSurface, waterFlow, surfaceNormals, availablePositions);
    }
    */
}
